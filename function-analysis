"""
NOTES:
- to do exponents do ** not ^
- def of a derivitive = f' = (f(x+h) - f(x))/h as h approaches 0
- print (x, ",", eval(f)) 

"""

from ggame import App, Color, LineStyle, Sprite, RectangleAsset, CircleAsset, EllipseAsset, PolygonAsset
from math import sin, cos, tan, radians

#inputs
f = input("enter a function equal to f(x) in terms of x: ")         #user inputs the funciton they want
#a = int(input("what is the lower limit of your interval?: "))      #user inputs the domain of the function 
#b = int(input("what is the upper limit of your interval?: "))      #user inputs the domain of the function
a = -5
b = 5
rangee = list(range(a,b+1))


fx = range(a, b+1)
(list(fx))   #list of x-values
h = 0.000001                 #defines delta x or h


########_finds f'
f1 = []                         # creates f1 which is a list that will contain y values for the function
for x in range(a,b+1):
    hk = eval(f)
    f1.append(hk)           #calcuates f(x) and puts in f1



fprime = []     #creates a list that will contain fprimes
crit = [a]
for x in range (a,b+1):         
   x = h+x                      #redefines x as x + h to find f(x+h)
   fh= eval(f)                  #calculates f(x+h)
   x = float(x-h+.1)-a            #redefines x so that it points to the coresponding f(x) value in f1
   p = round(((fh-f1[x])/h), 4) #rounds fprime
   fprime.append(p)             # calculates the derivitive using the definition of a derivitive and puts in fprime
   

for ppp in fprime:
    pos = fprime.index(ppp)         # position of ppp in fprime
    if ppp>= -0.05 and ppp<=0.05:
        x = rangee[pos]
        crit.append(x)
crit.append(b)          #adds b to critical values
print("critical x-values",crit)
for cc in crit:
    print("(", cc , "," , eval(f), ")")

#fhhh = []
#fxhh = []


for cc in crit:                 # add exceptions of x^3
    judy = crit.index(cc)
    x = cc
    jg = eval(f)
    x = judy+1
    # x = cc+0.1
    jjg = eval(f)
    if jg>jjg and judy<len(crit):
        print("local max @", cc , "," , jg)
    elif jg<jjg and judy<len(crit):
        print("local min @", cc, "," , jg)
    else:
        print("nein")
"""
x = b
clur = eval(f)
x = b-0.1
clurr = eval(f)
print("r",clur)
print ("rr", clurr)
if clur<clurr:
    print("local min @", b, "," , clur)
elif clur>clurr:
    print("local max @", b, "," , clur)
else:
    print("nein")  
"""
"""    
    judyy = crit.index(cc+1)
    print("judy", f1[judy])
    print("judyy", f1[judyy])
    if f1[judy]>f1[judyy] and judy<len(crit):
        print("local max @ ", "(", cc , "," , eval(f), ")")
    elif f1[judy]<f1[judyy] and judy<len(crit):
        print("local min @ ", "(", cc , "," , eval(f), ")")
    else:
        print("nope")
"""
"""
    x = x+100*h
    fhh = eval(f)
    fhhh.append(fhh)
    print("fhh", fhh)
    x = x
    fxh = eval(f)
    fxhh.append(fxh)
    print("fxh", fxh)
    if fhh>fxh:
        print("local min @", "(", x , "," , eval(f), ")")
    elif fhh<fxh:
        print("local max @", "(", x , "," , eval(f), ")")
    else:
        print("no local extrema")
"""



#prints function outputs
print (" ") 
print ("f(x) in range", a, "to", b, "equals: ") 
print (f1)

print (" ") 
print ("f'(x) in range", a, "to", b, "equals: ") 
print (fprime)




##############_finding f"

f2 = []                         # f(x+2h)-f(x+h)/h or f'(x+h)
for x in range (a,b+1):
    x = x + 2*h
    fj = eval(f)
    f2.append(fj)


f5 = []                         # f(x+2h)-f(x+h)/h or f'(x+h)
for x in range (a,b+1):   
    x = x+h
    fp = eval(f)
    f5.append(fp)


f6 = []
for x in range (a,b+1):
    q = (f2[x]-f5[x])/(h)
    f6.append(q)


f3 = []                         # f(x+h)-f(x)/h or f'(x)
for x in range(a, b+1):
    x = x + h
    fi = eval(f)
    f3.append(fi)
    
f4 = []                         # f(x+h)-f(x)/h or f'(x)
for x in range(a, b+1):  
    ae = (f3[x]-f1[x])/h
    f4.append(ae)
    

fdouble = []                    # actual f' 

for x in range (a-1, b):
    s = round((f6[x]-f4[x])/h, 2)
    fdouble.append(s)


print (" ")  
print ("f''(x) in range", a, "to", b, "equals: ") 
print (fdouble)
print("don")

print (" ") 

print("absolute min: ", (f1.index(x), min(f1)))
print("absolute max: ", (f1.index(x), max(f1)))

x=0
#for x in [.1(j)/ 100 for j in range(a, b+1, 1)]:       get it so incriments can be decimals
for x in range(a,b+1, 1):
    if fh[x] - f1[x] >= 0:
        print ("the function is increasing")
        slope_positive = 1
    if fh[x] - f1[x] <= 0:
        print ("the function is decreasing")
    
    






"""

while fprime[x] in range (a,b+1) <= 0:
    print ("for x in range ", x, "f(x) is decreasing")
    
    
if f1[x] <= 0:
    print ("f(x) is decreasing") 


if f1[x] >= 0:
    print ("f(x) is increasing") 

if fprime[x] <= 0:
    print ("f(x) is concave down") 

if fprime[x] >= 0:
    print ("f(x) is concave up") 
"""




"""
#####################_finds concavity using f''
#extrema at interior pts
if fdouble.append(eval(f))==0 in list(fprime) and fdouble.append(eval(f))<0 in list(fdouble) :
    print("local max @")
if fdouble.append(eval(f))==0 in list(fprime) and fdouble.append(eval(f))>0 in list(fdouble) :
    print("local min @")






#loop and figure out how to get x-value & include where fprime=DNE 1/0

#extrema at endpts
if fprime(a)<0:
    print ("local max @ x=", a)
if fprime(b)>0:
    print ("local max @ x=", a)
if fprime(b)<0:
    print ("local min @ x=", a)


#pts of inflection:
if fdouble.append(eval(f))=0 in list(fdouble) and
# +/-h are positive and negative=> POI
"""






























